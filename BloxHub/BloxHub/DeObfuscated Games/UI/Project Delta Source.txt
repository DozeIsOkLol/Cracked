-- Deobfuscated by SouljaWitchSrc

-- Load BloxHub Framework
local BloxHub = loadstring(game:HttpGet("https://raw.githubusercontent.com/ArtChivegroup/Roblox/refs/heads/main/script/addon/BloxHubUILib/source.lua"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Drawing Storage
local Drawings = {
    ESP = {},
    Tracers = {},
    Boxes = {},
    Healthbars = {},
    Names = {},
    Distances = {},
    Snaplines = {},
    Skeleton = {}
}

-- Color Configuration
local Colors = {
    Enemy = Color3.fromRGB(255, 0, 127),
    Ally = Color3.fromRGB(25, 255, 25),
    Neutral = Color3.fromRGB(255, 255, 255),
    Selected = Color3.fromRGB(255, 210, 0),
    Health = Color3.fromRGB(0, 255, 0),
    Distance = Color3.fromRGB(200, 200, 200),
    Rainbow = Color3.fromHSV(0, 1, 1)
}

local Highlights = {}
local worldLights = {}

-- Settings Configuration
local Settings = {
    Enabled = true,
    TeamCheck = false,
    ShowTeam = false,
    VisibilityCheck = true,
    BoxESP = true,
    BoxStyle = "Corner",
    BoxOutline = true,
    BoxFilled = false,
    BoxFillTransparency = 0.5,
    BoxThickness = 2,
    TracerESP = true,
    TracerOrigin = "Bottom",
    TracerStyle = "Line",
    TracerThickness = 2,
    HealthESP = true,
    HealthStyle = "Bar",
    HealthBarSide = "Left",
    HealthTextSuffix = "HP",
    NameESP = true,
    NameMode = "DisplayName",
    ShowDistance = true,
    DistanceUnit = "m",
    TextSize = 14,
    TextFont = 2,
    RainbowSpeed = 1,
    MaxDistance = 1000,
    RefreshRate = 1/144,
    Snaplines = false,
    SnaplineStyle = "Straight",
    RainbowEnabled = false,
    RainbowBoxes = false,
    RainbowTracers = false,
    RainbowText = false,
    ChamsEnabled = true,
    ChamsOutlineColor = Color3.fromRGB(255, 255, 0),
    ChamsFillColor = Color3.fromRGB(255, 0, 127),
    ChamsOccludedColor = Color3.fromRGB(150, 0, 0),
    ChamsTransparency = 0.3,
    ChamsOutlineTransparency = 0,
    ChamsOutlineThickness = 0.1,
    SkeletonESP = true,
    SkeletonColor = Color3.fromRGB(255, 255, 0),
    SkeletonThickness = 2,
    SkeletonTransparency = 1,
    
    -- Aimbot Settings
    AimbotEnabled = true,
    AimbotMode = "Hold",
    AimbotHoldKey = Enum.UserInputType.MouseButton2,
    AimbotFOV = 100,
    AimbotSmoothing = 0.5,
    AimbotPart = "Head",
    AimbotTeamCheck = false,
    AimbotVisibleCheck = false,
    ShowFOV = true,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVTransparency = 0.5,
    FOVFilled = false,
    
    -- World Light Settings
    WorldLightEnabled = false,
    WorldLightColor = Color3.fromRGB(0, 255, 0),
    WorldLightBrightness = 5,
    WorldLightRange = 60,
    
    -- Hotkey Settings
    HotkeyESPToggle = Enum.KeyCode.Z,
    HotkeyAimbotToggle = Enum.KeyCode.X,
    HotkeyWorldLight = Enum.KeyCode.N
}

-- Aimbot Variables
local aimbotActive = false
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 64
fovCircle.Radius = Settings.AimbotFOV
fovCircle.Filled = Settings.FOVFilled
fovCircle.Color = Settings.FOVColor
fovCircle.Transparency = Settings.FOVTransparency
fovCircle.Visible = Settings.ShowFOV
fovCircle.ZIndex = 1000

-- ==================== AIMBOT FUNCTIONS ====================

local function UpdateFOVCircle()
    local mousePos = UserInputService:GetMouseLocation()
    fovCircle.Position = mousePos
    fovCircle.Radius = Settings.AimbotFOV
    fovCircle.Color = Settings.FOVColor
    fovCircle.Transparency = Settings.FOVTransparency
    fovCircle.Filled = Settings.FOVFilled
    fovCircle.Visible = Settings.ShowFOV and Settings.AimbotEnabled
end

local function GetClosestPlayerToMouse()
    local closestPlayer = nil
    local shortestDistance = Settings.AimbotFOV
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                if Settings.AimbotTeamCheck and player.Team == LocalPlayer.Team then
                    continue
                end
                
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local targetPart = character:FindFirstChild(Settings.AimbotPart)
                    if targetPart then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                        
                        if onScreen then
                            if Settings.AimbotVisibleCheck then
                                local ray = Ray.new(
                                    Camera.CFrame.Position,
                                    (targetPart.Position - Camera.CFrame.Position).Unit * 1000
                                )
                                local hit = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character, Camera})
                                
                                if hit and not character:IsAncestorOf(hit) then
                                    continue
                                end
                            end
                            
                            local screenPosition = Vector2.new(screenPos.X, screenPos.Y)
                            local distance = (mousePos - screenPosition).Magnitude
                            
                            if distance < shortestDistance then
                                closestPlayer = player
                                shortestDistance = distance
                            end
                        end
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

local function AimAt(player)
    if not player or not player.Character then return end
    
    local targetPart = player.Character:FindFirstChild(Settings.AimbotPart)
    if not targetPart then return end
    
    local targetPosition = targetPart.Position
    local cameraPosition = Camera.CFrame.Position
    
    local direction = (targetPosition - cameraPosition).Unit
    local targetCFrame = CFrame.new(cameraPosition, cameraPosition + direction)
    
    if Settings.AimbotSmoothing > 0 then
        Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, 1 - Settings.AimbotSmoothing)
    else
        Camera.CFrame = targetCFrame
    end
end

-- ==================== WORLD LIGHT FUNCTIONS ====================

function createWorldLights()
    for _, light in ipairs(worldLights) do
        if light then light:Destroy() end
    end
    worldLights = {}
    
    for i = 1, 20 do
        local light = Instance.new("PointLight")
        light.Brightness = Settings.WorldLightBrightness
        light.Range = Settings.WorldLightRange
        light.Color = Settings.WorldLightColor
        
        local part = Instance.new("Part")
        part.Size = Vector3.new(1, 1, 1)
        part.Transparency = 1
        part.CanCollide = false
        part.Anchored = true
        part.Name = "DeltaLight"
        light.Parent = part
        part.Parent = workspace
        table.insert(worldLights, part)
    end
end

function updateWorldLights()
    if not Settings.WorldLightEnabled or #worldLights == 0 then return end
    
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        local radius = 100
        
        for i, lightPart in ipairs(worldLights) do
            local angle = (i / #worldLights) * math.pi * 2
            local x = math.cos(angle) * radius
            local z = math.sin(angle) * radius
            lightPart.Position = hrp.Position + Vector3.new(x, 20, z)
        end
    end
end

function toggleWorldLight()
    Settings.WorldLightEnabled = not Settings.WorldLightEnabled
    
    if Settings.WorldLightEnabled then
        createWorldLights()
        Lighting.Brightness = 2
        Lighting.Ambient = Color3.fromRGB(100, 255, 100)
    else
        for _, light in ipairs(worldLights) do
            if light then light:Destroy() end
        end
        worldLights = {}
        Lighting.Brightness = 1
        Lighting.Ambient = Color3.fromRGB(0, 0, 0)
    end
end

-- ==================== ESP FUNCTIONS ====================

local function CreateESP(player)
    if player == LocalPlayer then return end
    
    local box = {
        TopLeft = Drawing.new("Line"),
        TopRight = Drawing.new("Line"),
        BottomLeft = Drawing.new("Line"),
        BottomRight = Drawing.new("Line"),
        Left = Drawing.new("Line"),
        Right = Drawing.new("Line"),
        Top = Drawing.new("Line"),
        Bottom = Drawing.new("Line")
    }
    
    for _, line in pairs(box) do
        line.Visible = false
        line.Color = Colors.Enemy
        line.Thickness = Settings.BoxThickness
    end
    
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = Colors.Enemy
    tracer.Thickness = Settings.TracerThickness
    
    local healthBar = {
        Outline = Drawing.new("Square"),
        Fill = Drawing.new("Square"),
        Text = Drawing.new("Text")
    }
    
    for _, obj in pairs(healthBar) do
        obj.Visible = false
        if obj == healthBar.Fill then
            obj.Color = Colors.Health
            obj.Filled = true
        elseif obj == healthBar.Outline then
            obj.Color = Color3.fromRGB(0, 0, 0)
            obj.Filled = true
        elseif obj == healthBar.Text then
            obj.Center = true
            obj.Size = Settings.TextSize
            obj.Color = Colors.Health
            obj.Font = Settings.TextFont
            obj.Outline = true
        end
    end
    
    local info = {
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }
    
    for _, text in pairs(info) do
        text.Visible = false
        text.Center = true
        text.Size = Settings.TextSize
        text.Color = Colors.Enemy
        text.Font = Settings.TextFont
        text.Outline = true
    end
    
    local snapline = Drawing.new("Line")
    snapline.Visible = false
    snapline.Color = Colors.Enemy
    snapline.Thickness = 1
    
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Settings.ChamsFillColor
    highlight.OutlineColor = Settings.ChamsOutlineColor
    highlight.FillTransparency = Settings.ChamsTransparency
    highlight.OutlineTransparency = Settings.ChamsOutlineTransparency
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Enabled = Settings.ChamsEnabled
    
    if player.Character then
        highlight.Parent = player.Character
    end
    
    player.CharacterAdded:Connect(function(character)
        task.wait(0.1)
        highlight.Parent = character
    end)
    
    Highlights[player] = highlight
    
    local skeleton = {}
    for i = 1, 14 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = Settings.SkeletonColor
        line.Thickness = Settings.SkeletonThickness
        line.Transparency = Settings.SkeletonTransparency
        table.insert(skeleton, line)
    end
    
    Drawings.Skeleton[player] = skeleton
    
    Drawings.ESP[player] = {
        Box = box,
        Tracer = tracer,
        HealthBar = healthBar,
        Info = info,
        Snapline = snapline
    }
end

local function RemoveESP(player)
    local esp = Drawings.ESP[player]
    if esp then
        for _, obj in pairs(esp.Box) do 
            pcall(function() obj:Remove() end)
        end
        pcall(function() esp.Tracer:Remove() end)
        for _, obj in pairs(esp.HealthBar) do 
            pcall(function() obj:Remove() end)
        end
        for _, obj in pairs(esp.Info) do 
            pcall(function() obj:Remove() end)
        end
        pcall(function() esp.Snapline:Remove() end)
        Drawings.ESP[player] = nil
    end
    
    local highlight = Highlights[player]
    if highlight then
        pcall(function() highlight:Destroy() end)
        Highlights[player] = nil
    end
    
    local skeleton = Drawings.Skeleton[player]
    if skeleton then
        for _, line in pairs(skeleton) do
            pcall(function() line:Remove() end)
        end
        Drawings.Skeleton[player] = nil
    end
end

local function GetPlayerColor(player)
    if Settings.RainbowEnabled then
        return Colors.Rainbow
    end
    if player.Team == LocalPlayer.Team then
        return Colors.Ally
    end
    return Colors.Enemy
end

local function GetTracerOrigin()
    local origin = Settings.TracerOrigin
    if origin == "Bottom" then
        return Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
    elseif origin == "Top" then
        return Vector2.new(Camera.ViewportSize.X/2, 0)
    elseif origin == "Mouse" then
        return UserInputService:GetMouseLocation()
    else
        return Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    end
end

local function UpdateESP(player)
    if not Settings.Enabled then return end
    
    local esp = Drawings.ESP[player]
    if not esp then return end
    
    local character = player.Character
    if not character then 
        for _, obj in pairs(esp.Box) do obj.Visible = false end
        esp.Tracer.Visible = false
        for _, obj in pairs(esp.HealthBar) do obj.Visible = false end
        for _, obj in pairs(esp.Info) do obj.Visible = false end
        esp.Snapline.Visible = false
        
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
        return 
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    
    if not rootPart or not humanoid or humanoid.Health <= 0 then 
        for _, obj in pairs(esp.Box) do obj.Visible = false end
        esp.Tracer.Visible = false
        for _, obj in pairs(esp.HealthBar) do obj.Visible = false end
        for _, obj in pairs(esp.Info) do obj.Visible = false end
        esp.Snapline.Visible = false
        
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
        return 
    end
    
    local pos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
    
    if not onScreen or distance > Settings.MaxDistance then
        for _, obj in pairs(esp.Box) do obj.Visible = false end
        esp.Tracer.Visible = false
        for _, obj in pairs(esp.HealthBar) do obj.Visible = false end
        for _, obj in pairs(esp.Info) do obj.Visible = false end
        esp.Snapline.Visible = false
        
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
        return
    end
    
    if Settings.TeamCheck and player.Team == LocalPlayer.Team and not Settings.ShowTeam then
        for _, obj in pairs(esp.Box) do obj.Visible = false end
        esp.Tracer.Visible = false
        for _, obj in pairs(esp.HealthBar) do obj.Visible = false end
        for _, obj in pairs(esp.Info) do obj.Visible = false end
        esp.Snapline.Visible = false
        
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
        return
    end
    
    local color = GetPlayerColor(player)
    local size = character:GetExtentsSize()
    local cf = rootPart.CFrame
    
    local top, top_onscreen = Camera:WorldToViewportPoint(cf * CFrame.new(0, size.Y/2, 0).Position)
    local bottom, bottom_onscreen = Camera:WorldToViewportPoint(cf * CFrame.new(0, -size.Y/2, 0).Position)
    
    if not top_onscreen or not bottom_onscreen then
        for _, obj in pairs(esp.Box) do obj.Visible = false end
        return
    end
    
    local screenSize = bottom.Y - top.Y
    local boxWidth = screenSize * 0.65
    local boxPosition = Vector2.new(top.X - boxWidth/2, top.Y)
    local boxSize = Vector2.new(boxWidth, screenSize)
    
    for _, obj in pairs(esp.Box) do
        obj.Visible = false
    end
    
    if Settings.BoxESP then
        if Settings.BoxStyle == "Corner" then
            local cornerSize = boxWidth * 0.25
            
            esp.Box.TopLeft.From = boxPosition
            esp.Box.TopLeft.To = boxPosition + Vector2.new(cornerSize, 0)
            esp.Box.TopLeft.Visible = true
            
            esp.Box.TopRight.From = boxPosition + Vector2.new(boxSize.X, 0)
            esp.Box.TopRight.To = boxPosition + Vector2.new(boxSize.X - cornerSize, 0)
            esp.Box.TopRight.Visible = true
            
            esp.Box.BottomLeft.From = boxPosition + Vector2.new(0, boxSize.Y)
            esp.Box.BottomLeft.To = boxPosition + Vector2.new(cornerSize, boxSize.Y)
            esp.Box.BottomLeft.Visible = true
            
            esp.Box.BottomRight.From = boxPosition + Vector2.new(boxSize.X, boxSize.Y)
            esp.Box.BottomRight.To = boxPosition + Vector2.new(boxSize.X - cornerSize, boxSize.Y)
            esp.Box.BottomRight.Visible = true
            
            esp.Box.Left.From = boxPosition
            esp.Box.Left.To = boxPosition + Vector2.new(0, cornerSize)
            esp.Box.Left.Visible = true
            
            esp.Box.Right.From = boxPosition + Vector2.new(boxSize.X, 0)
            esp.Box.Right.To = boxPosition + Vector2.new(boxSize.X, cornerSize)
            esp.Box.Right.Visible = true
            
            esp.Box.Top.From = boxPosition + Vector2.new(0, boxSize.Y)
            esp.Box.Top.To = boxPosition + Vector2.new(0, boxSize.Y - cornerSize)
            esp.Box.Top.Visible = true
            
            esp.Box.Bottom.From = boxPosition + Vector2.new(boxSize.X, boxSize.Y)
            esp.Box.Bottom.To = boxPosition + Vector2.new(boxSize.X, boxSize.Y - cornerSize)
            esp.Box.Bottom.Visible = true
            
        else
            esp.Box.Left.From = boxPosition
            esp.Box.Left.To = boxPosition + Vector2.new(0, boxSize.Y)
            esp.Box.Left.Visible = true
            
            esp.Box.Right.From = boxPosition + Vector2.new(boxSize.X, 0)
            esp.Box.Right.To = boxPosition + Vector2.new(boxSize.X, boxSize.Y)
            esp.Box.Right.Visible = true
            
            esp.Box.Top.From = boxPosition
            esp.Box.Top.To = boxPosition + Vector2.new(boxSize.X, 0)
            esp.Box.Top.Visible = true
            
            esp.Box.Bottom.From = boxPosition + Vector2.new(0, boxSize.Y)
            esp.Box.Bottom.To = boxPosition + Vector2.new(boxSize.X, boxSize.Y)
            esp.Box.Bottom.Visible = true
        end
        
        for _, obj in pairs(esp.Box) do
            if obj.Visible then
                obj.Color = color
                obj.Thickness = Settings.BoxThickness
            end
        end
    end
    
    if Settings.TracerESP then
        esp.Tracer.From = GetTracerOrigin()
        esp.Tracer.To = Vector2.new(pos.X, pos.Y)
        esp.Tracer.Color = color
        esp.Tracer.Thickness = Settings.TracerThickness
        esp.Tracer.Visible = true
    else
        esp.Tracer.Visible = false
    end
    
    if Settings.HealthESP then
        local health = humanoid.Health
        local maxHealth = humanoid.MaxHealth
        local healthPercent = math.clamp(health/maxHealth, 0, 1)
        
        local barHeight = screenSize * 0.9
        local barWidth = 4
        local barPos = Vector2.new(
            boxPosition.X - barWidth - 4,
            boxPosition.Y + (screenSize - barHeight)/2
        )
        
        esp.HealthBar.Outline.Size = Vector2.new(barWidth + 2, barHeight + 2)
        esp.HealthBar.Outline.Position = Vector2.new(barPos.X - 1, barPos.Y - 1)
        esp.HealthBar.Outline.Visible = true
        
        esp.HealthBar.Fill.Size = Vector2.new(barWidth, (barHeight - 2) * healthPercent)
        esp.HealthBar.Fill.Position = Vector2.new(barPos.X, barPos.Y + (barHeight - 2) * (1 - healthPercent))
        esp.HealthBar.Fill.Color = Color3.fromRGB(255 - (255 * healthPercent), 255 * healthPercent, 0)
        esp.HealthBar.Fill.Visible = true
        
        if Settings.HealthStyle == "Both" or Settings.HealthStyle == "Text" then
            esp.HealthBar.Text.Text = math.floor(health) .. Settings.HealthTextSuffix
            esp.HealthBar.Text.Position = Vector2.new(barPos.X - 15, barPos.Y + barHeight/2)
            esp.HealthBar.Text.Color = Color3.fromRGB(255, 255, 255)
            esp.HealthBar.Text.Visible = true
        else
            esp.HealthBar.Text.Visible = false
        end
    else
        for _, obj in pairs(esp.HealthBar) do
            obj.Visible = false
        end
    end
    
    if Settings.NameESP then
        local nameText = player.DisplayName
        if Settings.ShowDistance then
            nameText = nameText .. " [" .. math.floor(distance) .. Settings.DistanceUnit .. "]"
        end
        esp.Info.Name.Text = nameText
        esp.Info.Name.Position = Vector2.new(
            boxPosition.X + boxWidth/2,
            boxPosition.Y - 18
        )
        esp.Info.Name.Color = color
        esp.Info.Name.Size = Settings.TextSize
        esp.Info.Name.Visible = true
    else
        esp.Info.Name.Visible = false
    end
    
    if Settings.Snaplines then
        esp.Snapline.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
        esp.Snapline.To = Vector2.new(pos.X, pos.Y)
        esp.Snapline.Color = color
        esp.Snapline.Visible = true
    else
        esp.Snapline.Visible = false
    end
    
    local highlight = Highlights[player]
    if highlight then
        if Settings.ChamsEnabled and character then
            highlight.Adornee = character
            highlight.FillColor = Settings.ChamsFillColor
            highlight.OutlineColor = Settings.ChamsOutlineColor
            highlight.FillTransparency = Settings.ChamsTransparency
            highlight.OutlineTransparency = Settings.ChamsOutlineTransparency
            highlight.Enabled = true
        else
            highlight.Enabled = false
        end
    end
    
    if Settings.SkeletonESP then
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            local bones = {
                {character:FindFirstChild("Head"), character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")},
                {character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"), character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso")},
                {character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"), character:FindFirstChild("LeftUpperArm") or character:FindFirstChild("Left Arm")},
                {character:FindFirstChild("LeftUpperArm") or character:FindFirstChild("Left Arm"), character:FindFirstChild("LeftLowerArm") or character:FindFirstChild("Left Arm")},
                {character:FindFirstChild("LeftLowerArm") or character:FindFirstChild("Left Arm"), character:FindFirstChild("LeftHand") or character:FindFirstChild("Left Arm")},
                {character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"), character:FindFirstChild("RightUpperArm") or character:FindFirstChild("Right Arm")},
                {character:FindFirstChild("RightUpperArm") or character:FindFirstChild("Right Arm"), character:FindFirstChild("RightLowerArm") or character:FindFirstChild("Right Arm")},
                {character:FindFirstChild("RightLowerArm") or character:FindFirstChild("Right Arm"), character:FindFirstChild("RightHand") or character:FindFirstChild("Right Arm")},
                {character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso"), character:FindFirstChild("LeftUpperLeg") or character:FindFirstChild("Left Leg")},
                {character:FindFirstChild("LeftUpperLeg") or character:FindFirstChild("Left Leg"), character:FindFirstChild("LeftLowerLeg") or character:FindFirstChild("Left Leg")},
                {character:FindFirstChild("LeftLowerLeg") or character:FindFirstChild("Left Leg"), character:FindFirstChild("LeftFoot") or character:FindFirstChild("Left Leg")},
                {character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso"), character:FindFirstChild("RightUpperLeg") or character:FindFirstChild("Right Leg")},
                {character:FindFirstChild("RightUpperLeg") or character:FindFirstChild("Right Leg"), character:FindFirstChild("RightLowerLeg") or character:FindFirstChild("Right Leg")},
                {character:FindFirstChild("RightLowerLeg") or character:FindFirstChild("Right Leg"), character:FindFirstChild("RightFoot") or character:FindFirstChild("Right Leg")}
            }
            
            for i, bone in ipairs(bones) do
                if skeleton[i] and bone[1] and bone[2] then
                    local fromPos, fromVisible = Camera:WorldToViewportPoint(bone[1].Position)
                    local toPos, toVisible = Camera:WorldToViewportPoint(bone[2].Position)
                    
                    if fromVisible and toVisible and fromPos.Z > 0 and toPos.Z > 0 then
                        skeleton[i].From = Vector2.new(fromPos.X, fromPos.Y)
                        skeleton[i].To = Vector2.new(toPos.X, toPos.Y)
                        skeleton[i].Color = Settings.SkeletonColor
                        skeleton[i].Thickness = Settings.SkeletonThickness
                        skeleton[i].Transparency = Settings.SkeletonTransparency
                        skeleton[i].Visible = true
                    else
                        skeleton[i].Visible = false
                    end
                else
                    if skeleton[i] then
                        skeleton[i].Visible = false
                    end
                end
            end
        end
    else
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
    end
end

local function DisableESP()
    for _, player in ipairs(Players:GetPlayers()) do
        local esp = Drawings.ESP[player]
        if esp then
            for _, obj in pairs(esp.Box) do obj.Visible = false end
            esp.Tracer.Visible = false
            for _, obj in pairs(esp.HealthBar) do obj.Visible = false end
            for _, obj in pairs(esp.Info) do obj.Visible = false end
            esp.Snapline.Visible = false
        end
        
        local skeleton = Drawings.Skeleton[player]
        if skeleton then
            for _, line in pairs(skeleton) do
                line.Visible = false
            end
        end
        
        local highlight = Highlights[player]
        if highlight then
            highlight.Enabled = false
        end
    end
end

local function CleanupESP()
    for _, player in ipairs(Players:GetPlayers()) do
        RemoveESP(player)
    end
    Drawings.ESP = {}
    Drawings.Skeleton = {}
    Highlights = {}
    if fovCircle then
        pcall(function() fovCircle:Remove() end)
    end
    for _, light in ipairs(worldLights) do
        if light then pcall(function() light:Destroy() end) end
    end
    worldLights = {}
end

-- ==================== CREATE BLOXHUB GUI ====================

local MainWindow = BloxHub:CreateWindow("PROJECT DELTA V3", {
    Size = UDim2.new(0, 580, 0, 600)
})

-- Create Tabs
local aimbotTab = MainWindow:CreateTab("Aimbot")
local espTab = MainWindow:CreateTab("ESP")
local visualTab = MainWindow:CreateTab("Visuals")
local worldTab = MainWindow:CreateTab("World")
local hotkeysTab = MainWindow:CreateTab("Hotkeys")
local settingsTab = MainWindow:CreateTab("Settings")

-- ==================== AIMBOT TAB ====================

aimbotTab:AddLabel("MAIN AIMBOT", {TextSize = 16, Bold = true})
aimbotTab:AddDivider()

aimbotTab:AddToggle("Enable Aimbot", true, function(state)
    Settings.AimbotEnabled = state
    fovCircle.Visible = Settings.ShowFOV and Settings.AimbotEnabled
    BloxHub:Notify("Aimbot", "Aimbot " .. (state and "Enabled" or "Disabled"), 2, "Info")
end)

aimbotTab:AddDropdown("Aimbot Mode", {"Hold", "Auto"}, function(mode)
    Settings.AimbotMode = mode
    if mode == "Auto" then
        aimbotActive = true
    else
        aimbotActive = false
    end
end)

aimbotTab:AddDropdown("Target Part", {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, function(part)
    Settings.AimbotPart = part
end)

aimbotTab:AddDivider()
aimbotTab:AddLabel("AIMBOT SETTINGS", {TextSize = 14, Bold = true})

aimbotTab:AddSlider("FOV Size", 20, 500, 100, function(value)
    Settings.AimbotFOV = value
end)

aimbotTab:AddSlider("Smoothing", 0, 0.95, 0.5, function(value)
    Settings.AimbotSmoothing = value
end)

aimbotTab:AddToggle("Team Check", false, function(state)
    Settings.AimbotTeamCheck = state
end)

aimbotTab:AddToggle("Visible Check", false, function(state)
    Settings.AimbotVisibleCheck = state
end)

aimbotTab:AddDivider()
aimbotTab:AddLabel("FOV CIRCLE", {TextSize = 14, Bold = true})

aimbotTab:AddToggle("Show FOV Circle", true, function(state)
    Settings.ShowFOV = state
    fovCircle.Visible = Settings.ShowFOV and Settings.AimbotEnabled
end)

aimbotTab:AddSlider("FOV Transparency", 0, 1, 0.5, function(value)
    Settings.FOVTransparency = value
end)

aimbotTab:AddToggle("Filled FOV", false, function(state)
    Settings.FOVFilled = state
end)

aimbotTab:AddDivider()
aimbotTab:AddLabel("Hold Right Mouse to aim (Hold Mode)", {TextSize = 12})

-- ==================== ESP TAB ====================

espTab:AddLabel("MAIN ESP", {TextSize = 16, Bold = true})
espTab:AddDivider()

espTab:AddToggle("Enable ESP", true, function(state)
    Settings.Enabled = state
    if not Settings.Enabled then
        DisableESP()
    end
    BloxHub:Notify("ESP", "ESP " .. (state and "Enabled" or "Disabled"), 2, "Info")
end)

espTab:AddToggle("Team Check", false, function(state)
    Settings.TeamCheck = state
end)

espTab:AddToggle("Show Team", false, function(state)
    Settings.ShowTeam = state
end)

espTab:AddDivider()
espTab:AddLabel("BOX ESP", {TextSize = 14, Bold = true})

espTab:AddToggle("Box ESP", true, function(state)
    Settings.BoxESP = state
end)

espTab:AddDropdown("Box Style", {"Corner", "Full"}, function(style)
    Settings.BoxStyle = style
end)

espTab:AddSlider("Box Thickness", 1, 5, 2, function(value)
    Settings.BoxThickness = value
end)

espTab:AddDivider()
espTab:AddLabel("TRACER ESP", {TextSize = 14, Bold = true})

espTab:AddToggle("Tracer ESP", true, function(state)
    Settings.TracerESP = state
end)

espTab:AddDropdown("Tracer Origin", {"Bottom", "Top", "Mouse", "Center"}, function(origin)
    Settings.TracerOrigin = origin
end)

espTab:AddSlider("Tracer Thickness", 1, 5, 2, function(value)
    Settings.TracerThickness = value
end)

espTab:AddDivider()
espTab:AddLabel("HEALTH ESP", {TextSize = 14, Bold = true})

espTab:AddToggle("Health Bar", true, function(state)
    Settings.HealthESP = state
end)

espTab:AddDropdown("Health Style", {"Bar", "Text", "Both"}, function(style)
    Settings.HealthStyle = style
end)

espTab:AddDivider()
espTab:AddLabel("NAME & DISTANCE", {TextSize = 14, Bold = true})

espTab:AddToggle("Show Names", true, function(state)
    Settings.NameESP = state
end)

espTab:AddToggle("Show Distance", true, function(state)
    Settings.ShowDistance = state
end)

espTab:AddTextBox("Distance Unit", "m", function(text, enterPressed)
    if enterPressed then
        Settings.DistanceUnit = text
    end
end)

espTab:AddDivider()
espTab:AddLabel("SKELETON ESP", {TextSize = 14, Bold = true})

espTab:AddToggle("Skeleton ESP", true, function(state)
    Settings.SkeletonESP = state
end)

espTab:AddSlider("Skeleton Thickness", 1, 5, 2, function(value)
    Settings.SkeletonThickness = value
end)

-- ==================== VISUALS TAB ====================

visualTab:AddLabel("CHAMS", {TextSize = 16, Bold = true})
visualTab:AddDivider()

visualTab:AddToggle("Enable Chams", true, function(state)
    Settings.ChamsEnabled = state
end)

visualTab:AddSlider("Chams Transparency", 0, 1, 0.3, function(value)
    Settings.ChamsTransparency = value
end)

visualTab:AddDivider()
visualTab:AddLabel("RAINBOW MODE", {TextSize = 14, Bold = true})

visualTab:AddToggle("Rainbow Mode", false, function(state)
    Settings.RainbowEnabled = state
end)

visualTab:AddSlider("Rainbow Speed", 0.1, 5, 1, function(value)
    Settings.RainbowSpeed = value
end)

visualTab:AddDivider()
visualTab:AddLabel("SNAPLINES", {TextSize = 14, Bold = true})

visualTab:AddToggle("Enable Snaplines", false, function(state)
    Settings.Snaplines = state
end)

-- ==================== WORLD TAB ====================

worldTab:AddLabel("WORLD LIGHTING", {TextSize = 16, Bold = true})
worldTab:AddDivider()

worldTab:AddToggle("Enable World Light", false, function(state)
    Settings.WorldLightEnabled = state
    toggleWorldLight()
    BloxHub:Notify("World Light", "World Light " .. (state and "Enabled" or "Disabled"), 2, "Info")
end)

worldTab:AddSlider("Light Brightness", 1, 10, 5, function(value)
    Settings.WorldLightBrightness = value
    for _, lightPart in ipairs(worldLights) do
        if lightPart and lightPart:FindFirstChildOfClass("PointLight") then
            lightPart:FindFirstChildOfClass("PointLight").Brightness = value
        end
    end
end)

worldTab:AddSlider("Light Range", 20, 100, 60, function(value)
    Settings.WorldLightRange = value
    for _, lightPart in ipairs(worldLights) do
        if lightPart and lightPart:FindFirstChildOfClass("PointLight") then
            lightPart:FindFirstChildOfClass("PointLight").Range = value
        end
    end
end)

worldTab:AddDivider()
worldTab:AddLabel("AMBIENT LIGHTING", {TextSize = 14, Bold = true})

worldTab:AddSlider("World Brightness", 0, 5, 1, function(value)
    Lighting.Brightness = value
end)

-- ==================== HOTKEYS TAB ====================

hotkeysTab:AddLabel("CUSTOM HOTKEYS", {TextSize = 16, Bold = true})
hotkeysTab:AddDivider()

hotkeysTab:AddLabel("Current Hotkeys:")
hotkeysTab:AddLabel("ESP Toggle: " .. Settings.HotkeyESPToggle.Name)
hotkeysTab:AddLabel("Aimbot Toggle: " .. Settings.HotkeyAimbotToggle.Name)
hotkeysTab:AddLabel("World Light: " .. Settings.HotkeyWorldLight.Name)
hotkeysTab:AddLabel("Toggle GUI: LeftAlt / RightAlt")

hotkeysTab:AddDivider()

hotkeysTab:AddButton("Change ESP Hotkey", function()
    BloxHub:Notify("Hotkey Setup", "Press any key for ESP Toggle...", 3, "Info")
    
    local connection
    connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode ~= Enum.KeyCode.Unknown then
            Settings.HotkeyESPToggle = input.KeyCode
            BloxHub:Notify("Hotkey Set", "ESP Toggle: " .. input.KeyCode.Name, 2, "Success")
            connection:Disconnect()
        end
    end)
end)

hotkeysTab:AddButton("Change Aimbot Hotkey", function()
    BloxHub:Notify("Hotkey Setup", "Press any key for Aimbot Toggle...", 3, "Info")
    
    local connection
    connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode ~= Enum.KeyCode.Unknown then
            Settings.HotkeyAimbotToggle = input.KeyCode
            BloxHub:Notify("Hotkey Set", "Aimbot Toggle: " .. input.KeyCode.Name, 2, "Success")
            connection:Disconnect()
        end
    end)
end)

hotkeysTab:AddButton("Change World Light Hotkey", function()
    BloxHub:Notify("Hotkey Setup", "Press any key for World Light...", 3, "Info")
    
    local connection
    connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode ~= Enum.KeyCode.Unknown then
            Settings.HotkeyWorldLight = input.KeyCode
            BloxHub:Notify("Hotkey Set", "World Light: " .. input.KeyCode.Name, 2, "Success")
            connection:Disconnect()
        end
    end)
end)

-- ==================== SETTINGS TAB ====================

settingsTab:AddLabel("PERFORMANCE", {TextSize = 16, Bold = true})
settingsTab:AddDivider()

settingsTab:AddSlider("Max ESP Distance", 100, 5000, 1000, function(value)
    Settings.MaxDistance = value
end)

settingsTab:AddSlider("Refresh Rate (FPS)", 30, 240, 144, function(value)
    Settings.RefreshRate = 1/value
end)

settingsTab:AddDivider()
settingsTab:AddLabel("TEXT SETTINGS", {TextSize = 14, Bold = true})

settingsTab:AddSlider("Text Size", 10, 24, 14, function(value)
    Settings.TextSize = value
end)

settingsTab:AddDropdown("Text Font", {"UI", "System", "Plex", "Monospace"}, function(font)
    if font == "UI" then Settings.TextFont = 0 end
    if font == "System" then Settings.TextFont = 1 end
    if font == "Plex" then Settings.TextFont = 2 end
    if font == "Monospace" then Settings.TextFont = 3 end
end)

settingsTab:AddDivider()
settingsTab:AddLabel("CONFIGURATION", {TextSize = 14, Bold = true})

settingsTab:AddButton("Save Settings", function()
    BloxHub:SaveConfig()
    BloxHub:Notify("Saved", "Settings saved successfully!", 3, "Success")
end)

settingsTab:AddButton("Load Settings", function()
    BloxHub:LoadConfig()
    BloxHub:Notify("Loaded", "Settings loaded successfully!", 3, "Success")
end)

settingsTab:AddDivider()

settingsTab:AddDropdown("Theme", {"Dark", "Light", "Purple", "Green"}, function(theme)
    BloxHub:SetTheme(theme)
    BloxHub:Notify("Theme Changed", "Theme set to " .. theme, 2, "Info")
end)

settingsTab:AddDivider()

settingsTab:AddButton("Unload Script", function()
    BloxHub:Notify("Warning", "Unloading script in 2 seconds...", 2, "Warning")
    task.wait(2)
    CleanupESP()
    _G.ProjectDeltaUnloaded = true
end)

-- ==================== HOTKEY REGISTRATION ====================

-- Register Alt key for toggle GUI
MainWindow:RegisterHotkey("ToggleGUI", Enum.KeyCode.LeftAlt, function()
    MainWindow:Toggle()
end)

MainWindow:RegisterHotkey("ToggleGUI2", Enum.KeyCode.RightAlt, function()
    MainWindow:Toggle()
end)

-- ==================== INPUT HANDLING ====================

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if Settings.AimbotEnabled then
        if Settings.AimbotMode == "Hold" and input.UserInputType == Settings.AimbotHoldKey then
            aimbotActive = true
        end
    end
    
    -- Custom Hotkeys
    if input.KeyCode == Settings.HotkeyESPToggle then
        Settings.Enabled = not Settings.Enabled
        if not Settings.Enabled then
            DisableESP()
        end
        BloxHub:Notify("ESP", "ESP " .. (Settings.Enabled and "Enabled" or "Disabled"), 2, "Info")
    elseif input.KeyCode == Settings.HotkeyAimbotToggle then
        Settings.AimbotEnabled = not Settings.AimbotEnabled
        fovCircle.Visible = Settings.ShowFOV and Settings.AimbotEnabled
        BloxHub:Notify("Aimbot", "Aimbot " .. (Settings.AimbotEnabled and "Enabled" or "Disabled"), 2, "Info")
    elseif input.KeyCode == Settings.HotkeyWorldLight then
        toggleWorldLight()
        BloxHub:Notify("World Light", "World Light " .. (Settings.WorldLightEnabled and "Enabled" or "Disabled"), 2, "Info")
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if Settings.AimbotMode == "Hold" and input.UserInputType == Settings.AimbotHoldKey then
        aimbotActive = false
    end
end)

-- ==================== MAIN LOOPS ====================

-- Rainbow effect
task.spawn(function()
    while task.wait(0.1) and not _G.ProjectDeltaUnloaded do
        if Settings.RainbowEnabled then
            Colors.Rainbow = Color3.fromHSV(tick() * Settings.RainbowSpeed % 1, 1, 1)
        end
    end
end)

-- Handle players
Players.PlayerAdded:Connect(CreateESP)
Players.PlayerRemoving:Connect(RemoveESP)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

-- Main update loop
local lastUpdate = 0
RunService.RenderStepped:Connect(function()
    if _G.ProjectDeltaUnloaded then return end

    -- Update functions
    updateWorldLights()
    UpdateFOVCircle()
    
    -- Aimbot logic
    if Settings.AimbotEnabled and aimbotActive then
        local target = GetClosestPlayerToMouse()
        if target then
            AimAt(target)
        end
    end
    
    -- ESP update logic
    if not Settings.Enabled then 
        DisableESP()
        return 
    end
    
    if (tick() - lastUpdate) >= Settings.RefreshRate then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                if not Drawings.ESP[player] then
                    CreateESP(player)
                end
                UpdateESP(player)
            end
        end
        lastUpdate = tick()
    end
end)

-- ==================== FINAL SETUP ====================

-- Create floating icon
BloxHub:CreateFloatingIcon(MainWindow, {
    Text = "DELTA",
    ShowOnMinimize = true
})

-- Success notification
BloxHub:Notify("PROJECT DELTA V3", "Loaded successfully! Press Alt to toggle GUI.", 5, "Success")
